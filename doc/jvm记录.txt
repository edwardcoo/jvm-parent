1.方法递归时，会创建多少个栈帧
	方法每次执行就会创建一个栈帧，无限递归或者大量递归会出现栈溢出异常
2.新生代 8:1:1原因
	新生代存活对象比例较低，80%eden区 + 10%s0区 + 10%s1区
	-XX:SurvivorRatio可以设置eden区与Survivor区比例，-XX:NewRatio可以设置老年代新生代的比例。
3.什么样的对象可以被回收
	没有任何被引用，GC Root不可达的时候，对象状态不可达的时候
4.什么是GC Root（gc是检索被引用对象，然后对其余对象进行gc回收）
	gc根节点，
	虚拟机栈中的引用对象(方法本地变量表)
	方法区中类静态属性引用的对象(static)
	方法区中常量引用的对象(final)
	本地方法栈中JNI引用的对象(方法本地变量表)
5.回收算法
	根搜索算法
		5.1标记-清除算法
			效率较低（遍历全部对象），GC的时候需要停止应用程序
			gc后的空闲内存是不连续的，需要维护一个空闲列表
		5.2复制算法
			分为活动区域和空闲区域，
			一半内存空间是空闲的，资源浪费
		5.3标记-整理算法
			标记-》整理内存，效率也不高
		分代搜集算法--》新生代
	新生代--》复制算法
	老年代--》标记-清除或者标记-整理算法